---
title: About Shader Designer nodes
description: Learn about the various Shader Designer nodes that you can use to create graphics effects.
ms.date: 06/30/2023
ms.topic: overview
author: Mikejo5000
ms.author: mikejo
manager: mijacobs
ms.subservice: ui-designers
---
# What are Shader Designer nodes?

The Shader Designer in Visual Studio represents visual effects as a graph. These graphs are built from nodes that are chosen and connected in precise ways to achieve the intended effect. Each node represents either a piece of information or a mathematical function, and the connections between them represent how the information flows through the graph to produce the result. Node types include [filters](#filter-nodes), [textures](#texture-nodes), [parameters](#parameter-nodes), [constants](#constant-nodes), [utility](#utility-nodes) nodes, and [math](#math-nodes) nodes.

## Node structure

All nodes are made up of a combination of common elements. Every node has at least one output terminal on its right-hand side (except the final color node, which represents the output of the shader). Nodes that represent calculations or texture samplers have input terminals on their left-hand sides, but nodes that represent information have no input terminals. Output terminals are connected to input terminals to move information from one node to another.

### Promotion of inputs

Because the Shader Designer must ultimately generate HLSL source code so that the effect can be used in a game or app, Shader Designer nodes are subject to the type-promotion rules that HLSL uses. Because graphics hardware operates primarily on floating-point values, type promotion between different types&mdash;for example, from `int` to `float`, or from `float` to `double`&mdash;is uncommon. Instead, because graphics hardware uses the same operation on multiple pieces of information at once, a different kind of promotion can occur in which the shorter of many inputs is lengthened to match the size of the longest input. How it's lengthened depends on the type of the input, and also on the operation itself:

- **If the smaller type is a scalar value, then:**

     The value of the scalar is replicated into a vector that is equal in size to the larger input. For example, the scalar input 5.0 becomes the vector (5.0, 5.0, 5.0) when the largest input of the operation is a three-element vector, regardless of what the operation is.

- **If the smaller type is a vector, and the operation is multiplicative (\*, /, %, and so on), then:**

     The value of the vector is copied into the leading elements of a vector that is equal in size to the larger input, and the trailing elements are set to 1.0. For example, the vector input (5.0, 5.0) becomes the vector (5.0, 5.0, 1.0, 1.0) when it's multiplied by a four-element vector. This preserves the third and fourth elements of the output by using the multiplicative identity, 1.0.

- **If the smaller type is a vector, and the operation is additive (+, -, and so on), then:**

     The value of the vector is copied into the leading elements of a vector that is equal in size to the larger input, and the trailing elements are set to 0.0. For example, the vector input (5.0, 5.0) becomes the vector (5.0, 5.0, 0.0, 0.0) when it's added to a four-element vector. This preserves the third and fourth elements of the output by using the additive identity, 0.0.

## Nodes and node types

The Shader Designer provides six different node types&mdash;filters, texture nodes, parameters, constants, utility nodes, and math nodes&mdash;and several individual nodes belong to each type.

### Constant nodes

In the Shader Designer, constant nodes represent literal values and interpolated vertex attributes in pixel-shader calculations. Because vertex attributes are interpolated—and so, are different for each pixel—each pixel-shader instance receives a different version of the constant. This gives each pixel a unique appearance.

#### Vertex attribute interpolation

The image of a 3D scene in a game or app is made by mathematically transforming many objects—which are defined by vertices, vertex attributes, and primitive definitions—into on-screen pixels. All of the information that's required to give a pixel its unique appearance is supplied through vertex attributes, which are blended together according to the pixel's proximity to the different vertices that make up its *primitive*. A primitive is a basic rendering element; that is, a simple shape such as a point, a line, or a triangle. A pixel that's very close to just one of the vertices receives constants that are nearly identical to that vertex, but a pixel that's evenly spaced between all the vertices of a primitive receives constants that are the average of those vertices. In graphics programming, the constants that the pixels receive are said to be *interpolated*. Providing constant data to pixels in this way produces good visual quality and at the same time reduces memory footprint and bandwidth requirements.

Although each pixel-shader instance receives only one set of constant values and can't change these values, different pixel-shader instances receive different sets of constant data. This design enables a shader program to produce a different color output for each pixel in the primitive.

#### Constant node reference

|Node|Details|Properties|
|----------|-------------|----------------|
|**Camera Vector**|The vector that extends from the current pixel to the camera in world space.<br /><br /> You can use this to calculate reflections in world space.<br /><br /> **Output**<br /><br /> `Output`: `float3`<br /> The vector from the current pixel to the camera.|None|
|**Color Constant**|A constant color value.<br /><br /> **Output**<br /><br /> `Output`: `float4`<br /> The color value.|**Output**<br /> The color value.|
|**Constant**|A constant scalar value.<br /><br /> **Output**<br /><br /> `Output`: `float`<br /> The scalar value.|**Output**<br /> The scalar value.|
|**2D Constant**|A two-component vector constant.<br /><br /> **Output**<br /><br /> `Output`: `float2`<br /> The vector value.|**Output**<br /> The vector value.|
|**3D Constant**|A three-component vector constant.<br /><br /> **Output**<br /><br /> `Output`: `float3`<br /> The vector value.|**Output**<br /> The vector value.|
|**4D Constant**|A four-component vector constant.<br /><br /> **Output**<br /><br /> `Output`: `float4`<br /> The color value.|**Output**<br /> The vector value.|
|**Normalized Position**|The position of the current pixel, expressed in normalized device coordinates.<br /><br /> The x-coordinate and y-coordinate have values in the range of [-1, 1], the z-coordinate has a value in the range of [0, 1], and the w component contains the point depth value in view space; w isn't normalized.<br /><br /> **Output**<br /><br /> `Output`: `float4`<br /> The position of the current pixel.|None|
|**Point Color**|The diffuse color of the current pixel, which is a combination of the material diffuse color and vertex color attributes.<br /><br /> **Output**<br /><br /> `Output`: `float4`<br /> The diffuse color of the current pixel.|None|
|**Point Depth**|The depth of the current pixel in view space.<br /><br /> **Output**<br /><br /> `Output`: `float`<br /> The depth of the current pixel.|None|
|**Normalized Point Depth**|The depth of the current pixel, expressed in normalized device coordinates.<br /><br /> The result has a value in the range of [0, 1].<br /><br /> **Output**<br /><br /> `Output`: `float`<br /> The depth of the current pixel.|None|
|**Screen Position**|The position of the current pixel, expressed in screen coordinates.<br /><br /> The screen coordinates are based on the current viewport. The x and y components contain the screen coordinates, the z component contains the depth normalized to a range of [0, 1], and the w component contains the depth value in view space.<br /><br /> **Output**<br /><br /> `Output`: `float4`<br /> The position of the current pixel.|None|
|**Surface Normal**|The surface normal of the current pixel in object space.<br /><br /> You can use this to calculate lighting contributions and reflections in object space.<br /><br /> **Output**<br /><br /> `Output`: `float3`<br /> The surface normal of the current pixel.|None|
|**Tangent Space Camera Vector**|The vector that extends from the current pixel to the camera in tangent space.<br /><br /> You can use this to calculate reflections in tangent space.<br /><br /> **Output**<br /><br /> `Output`: `float3`<br /> The vector from the current pixel to the camera.|None|
|**Tangent Space Light Direction**|The vector that defines the direction in which light is cast from a light source in the tangent space of the current pixel.<br /><br /> You can use this to calculate lighting and specular contributions in tangent space.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The vector from the current pixel to a light source.|None|
|**World Normal**|The surface normal of the current pixel in world space.<br /><br /> You can use this to calculate lighting contributions and reflections in world space.<br /><br /> **Output**<br /><br /> `Output`: `float3`<br /> The surface normal of the current pixel.|None|
|**World Position**|The position of the current pixel in world space.<br /><br /> **Output**<br /><br /> `Output`: `float4`<br /> The position of the current pixel.|None|

### Parameter nodes

In the Shader Designer, parameter nodes represent inputs to the shader that are under the control of the app on a per-draw basis, for example, material properties, directional lights, camera position, and time. Because you can change these parameters with each draw call, you can use the same shader to give an object different appearances.

#### Parameter node reference

|Node|Details|Properties|
|----------|-------------|----------------|
|**Camera World Position**|The position of the camera in world space.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The position of the camera.|None|
|**Light Direction**|The vector that defines the direction in which light is cast from a light source in world space.<br /><br /> You can use this to calculate lighting and specular contributions in world space.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The vector from the current pixel to a light source.|None|
|**Material Ambient**|The diffuse color contribution of the current pixel that is attributed to indirect lighting.<br /><br /> The diffuse color of a pixel simulates how lighting interacts with rough surfaces. You can use the Material Ambient parameter to approximate how indirect lighting contributes to the appearance of an object in the real world.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The diffuse color of the current pixel that's due to indirect&mdash;that is, ambient&mdash;lighting.|**Access**<br /> **Public** to enable the property to be set from the Model Editor; otherwise, **Private**.<br /><br /> **Value**<br /> The diffuse color of the current pixel that's due to indirect—that is, ambient—lighting.|
|**Material Diffuse**|A color that describes how the current pixel diffuses direct lighting.<br /><br /> The diffuse color of a pixel simulates how lighting interacts with rough surfaces. You can use the Material Diffuse parameter to change how the current pixel diffuses direct lighting—that is, directional, point, and spot lights.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> A color that describes how the current pixel diffuses direct lighting.|**Access**<br /> **Public** to enable the property to be set from the Model Editor; otherwise, **Private**.<br /><br /> **Value**<br /> A color that describes how the current pixel diffuses direct lighting.|
|**Material Emissive**|The color contribution of the current pixel that is attributed to lighting that it supplies to itself.<br /><br /> You can use this to simulate a glowing object; that is, an object that supplies its own light. This light doesn't affect other objects.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The color contribution of the current pixel that's due to self-provided lighting.|**Access**<br /> **Public** to enable the property to be set from the Model Editor; otherwise, **Private**.<br /><br /> **Value**<br /> The color contribution of the current pixel that's due to self-provided lighting.|
|**Material Specular**|A color that describes how the current pixel reflects direct lighting.<br /><br /> The specular color of a pixel simulates how lighting interacts with smooth, mirror-like surfaces. You can use the Material Specular parameter to change how the current pixel reflects direct lighting—that is, directional, point, and spot lights.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> A color that describes how the current pixel reflects direct lighting.|**Access**<br /> **Public** to allow the property to be set from the Model Editor; otherwise, **Private**.<br /><br /> **Value**<br /> A color that describes how the current pixel reflects direct lighting.|
|**Material Specular Power**|A scalar value that describes the intensity of specular highlights.<br /><br /> The larger the specular power, the more intense and far-reaching the specular highlights become.<br /><br /> **Output:**<br /><br /> `Output`: `float`<br /> An exponential term that describes the intensity of specular highlights on the current pixel.|**Access**<br /> **Public** to enable the property to be set from the Model Editor; otherwise, **Private**.<br /><br /> **Value**<br /> The exponent that defines the intensity of specular highlights on the current pixel.|
|**Normalized Time**|The time in seconds, normalized to the range [0, 1], such that when time reaches 1, it resets to 0.<br /><br /> You can use this as a parameter in shader calculations, for example, to animate texture coordinates, color values, or other attributes.<br /><br /> **Output:**<br /><br /> `Output`: `float`<br /> The normalized time, in seconds.|None|
|**Time**|The time in seconds.<br /><br /> You can use this as a parameter in shader calculations, for example, to animate texture coordinates, color values, or other attributes.<br /><br /> **Output:**<br /><br /> `Output`: `float`<br /> The time, in seconds.|None|

### Texture nodes

In the Shader Designer, texture nodes sample various texture types and geometries, and produce or transform texture coordinates. Textures provide color and lighting detail on objects.

#### Texture node reference

|Node|Details|Properties|
|----------|-------------|----------------|
|**Cubemap Sample**|Takes a color sample from a cubemap at the specified coordinates.<br /><br /> You can use a cubemap to provide color detail for reflection effects, or to apply to a spherical object a texture that has less distortion than a 2D texture.<br /><br /> **Input:**<br /><br /> `UVW`: `float3`<br /> A vector that specifies the location on the texture cube where the sample is taken. The sample is taken where this vector intersects the cube.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The color sample.|**Texture**<br /> The texture register that's associated with the sampler.|
|**Normal Map Sample**|Takes a normal sample from a 2D normal map at the specified coordinates<br /><br /> You can use a normal map to simulate the appearance of additional geometric detail on the surface of an object. Normal maps contain packed data that represents a unit vector instead of color data<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates where the sample is taken.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The normal sample.|**Axis Adjustment**<br /> The factor that's used to adjust the handiness of the normal map sample.<br /><br /> **Texture**<br /> The texture register that's associated with the sampler.|
|**Pan UV**|Pans the specified texture coordinates as a function of time.<br /><br /> You can use this to move a texture or normal map across the surface of an object.<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates to pan.<br /><br /> `Time`: `float`<br /> The length of time to pan by, in seconds.<br /><br /> **Output:**<br /><br /> `Output`: `float2`<br /> The panned coordinates.|**Speed X**<br /> The number of texels that are panned along the x axis, per second.<br /><br /> **Speed Y**<br /> The number of texels that are panned along the y axis, per second.|
|**Parallax UV**|Displaces the specified texture coordinates as a function of height and viewing angle.<br /><br /> The effect this creates is known as *parallax mapping*, or virtual displacement mapping. You can use it to create an illusion of depth on a flat surface.<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates to displace.<br /><br /> `Height`: `float`<br /> The heightmap value that's associated with the `UV` coordinates.<br /><br /> **Output:**<br /><br /> `Output`: `float2`<br /> The displaced coordinates.|**Depth Plane**<br /> The reference depth for the parallax effect. By default, the value is 0.5. Smaller values lift the texture; larger values sink it into the surface.<br /><br /> **Depth Scale**<br /> The scale of the parallax effect. This makes the apparent depth more or less pronounced. Typical values range from 0.02 to 0.1.|
|**Rotate UV**|Rotates the specified texture coordinates around a central point as a function of time.<br /><br /> You can use this to spin a texture or normal map on the surface of an object.<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates to rotate.<br /><br /> `Time`: `float`<br /> The length of time to pan by, in seconds.<br /><br /> **Output:**<br /><br /> `Output`: `float2`<br /> The rotated coordinates.|**Center X**<br /> The x coordinate that defines the center of rotation.<br /><br /> **Center Y**<br /> The y coordinate that defines the center of rotation.<br /><br /> **Speed**<br /> The angle, in radians, by which the texture rotates per second.|
|**Texture Coordinate**|The texture coordinates of the current pixel.<br /><br /> The texture coordinates are determined by interpolating among the texture coordinate attributes of nearby vertices. You can think of this as the position of the current pixel in texture space.<br /><br /> **Output:**<br /><br /> `Output`: `float2`<br /> The texture coordinates.|None|
|**Texture Dimensions**|Outputs the width and height of a 2D texture map.<br /><br /> You can use the texture dimensions to consider the width and height of the texture in a shader.<br /><br /> **Output:**<br /><br /> `Output`: `float2`<br /> The width and height of the texture, expressed as a vector. The width is stored in the first element of the vector. The height is stored in the second element.|**Texture**<br /> The texture register that's associated with the texture dimensions.|
|**Texel Delta**|Outputs the delta (distance) between the texels of a 2D texture map.<br /><br /> You can use the texel delta to sample neighboring texel values in a shader.<br /><br /> **Output:**<br /><br /> `Output`: `float2`<br /> The delta (distance) from a texel to the next texel (moving diagonally in the positive direction), expressed as a vector in normalized texture space. You can derive the positions of all neighboring texels by selectively ignoring or negating the U or V coordinates of the delta.|**Texture**<br /> The texture register that's associated with the texel delta.|
|**Texture Sample**|Takes a color sample from a 2D texture map at the specified coordinates.<br /><br /> You can use a texture map to provide color detail on the surface of an object.<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates where the sample is taken.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The color sample.|**Texture**<br /> The texture register that's associated with the sampler.|

### Math nodes

In the Shader Designer, math nodes perform algebraic, logic, trigonometric, and other mathematical operations.

> [!NOTE]
> When you work with math nodes in the Shader Designer, type promotion is especially evident. For more information about how type promotion affects input parameters, see the [Promotion of inputs](#promotion-of-inputs) section.

#### Math node reference

|Node|Details|Properties|
|----------|-------------|----------------|
|**Abs**|Computes the absolute value of the specified input per component.<br /><br /> For each component of input `X`, negative values are made positive so that every component of the result has a positive value.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values for which to determine the absolute value.<br /><br /> `Output:`<br /><br /> `Output`: same as input `X`<br /> The absolute value, per component.|None|
|**Add**|Computes the component-wise sum of the specified inputs per component.<br /><br /> For each component of the result, the corresponding components of input `X` and input `Y` are added together.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> One of the values to add together.<br /><br /> `Y`: same as input `X`<br /> One of the values to add together.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The sum, per component.|None|
|**Ceil**|Computes the ceiling of the specified input per component.<br /><br /> The ceiling of a value is the smallest integer that's greater than or equal to that value.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values for which to compute the ceiling.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The ceiling, per component.|None|
|**Clamp**|Clamps each component of the specified input to a predefined range.<br /><br /> For each component of the result, values that are below the defined range are made equal to the minimum value in the range, values that are above the defined range are made equal to the maximum value in the range, and values that are in the range aren't changed.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values to clamp.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The clamped value, per component.|**Max**<br /> The largest possible value in the range.<br /><br /> **Min**<br /> The smallest possible value in the range.|
|**Cos**|Computes the cosine of the specified input, in radians, per component.<br /><br /> For each component of the result, the cosine of the corresponding component, which is provided in radians, is calculated. The result has components that have values in the range of [-1, 1].<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values to compute the cosine of, in radians.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The cosine, per component.|None|
|**Cross**|Computes the cross product of the specified three-component vectors.<br /><br /> You can use the cross product to compute the normal of a surface that's defined by two vectors.<br /><br /> **Input:**<br /><br /> `X`: `float3`<br /> The vector on the left-hand-side of the cross product.<br /><br /> `Y`: `float3`<br /> The vector on the right-hand-side of the cross product.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The cross product.|None|
|**Distance**|Computes the distance between the specified points.<br /><br /> The result is a positive scalar value.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> One of the points to determine the distance between.<br /><br /> `Y`: same as input `X`<br /> One of the points to determine the distance between.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The distance.|None|
|**Divide**|Computes the component-wise quotient of the specified inputs.<br /><br /> For each component of the result, the corresponding component of input `X` is divided by the corresponding component of input `Y`.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The dividend values.<br /><br /> `Y`: same as input `X`<br /> The divisor values.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The quotient, per component.|None|
|**Dot**|Computes the dot product of the specified vectors.<br /><br /> The result is a scalar value. You can use the dot product to determine the angle between two vectors.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> One of the terms.<br /><br /> `Y`: same as input `X`<br /> One of the terms.<br /><br /> **Output:**<br /><br /> `Output`: `float`<br /> The dot product.|None|
|**Floor**|Computes the floor of the specified input per component.<br /><br /> For each component of the result, its value is the largest whole integer value that's less than or equal to the corresponding component of the input. Every component of the result is a whole integer.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values for which to compute the floor.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The floor, per component.|None|
|**Fmod**|Computes the component-wise modulus (remainder) of the specified inputs.<br /><br /> For each component of the result, some integral (whole-number) multiple, m, of the corresponding component of input `Y` is subtracted from the corresponding component of input `X`, leaving a remainder. The multiple, m, is chosen such that the remainder is less than the corresponding component of input `Y` and has the same sign as the corresponding component of input `X`. For example, fmod(-3.14, 1.5) is -0.14.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The dividend values.<br /><br /> `Y`: same as input `X`<br /> The divisor values.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The modulus, per component.|None|
|**Frac**|Removes the integral (whole-number) part of the specified input per component.<br /><br /> For each component of the result, the integral part of the corresponding component of the input is removed, but the fractional part and sign are retained. This fractional value falls in the range [0, 1). For example, the value -3.14 becomes the value -0.14.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values for which to compute the fractional part.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The fractional part, per component.|None|
|**Lerp**|Linear Interpolation. Computes the component-wise weighted average of the specified inputs.<br /><br /> For each component of the result, the weighted average of the corresponding components of the inputs `X` and `Y`. The weight is provided by `Percent`, a scalar, and is uniformly applied to all components. You can use this to interpolate between points, colors, attributes, and other values.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The originating value. When `Percent` is zero, the result is equal to this input.<br /><br /> `Y`: same as input `X`<br /> The terminal value. When `Percent` is one, the result is equal to this input.<br /><br /> `Percent`: `float`<br /> A scalar weight that's expressed as a percentage of the distance from input `X` towards input `Y`.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> A value that's collinear with the specified inputs.|None|
|**Multiply Add**|Computes the component-wise multiply-add of the specified inputs.<br /><br /> For each component of the result, the product of the corresponding components of the inputs `M` and `A` is added to the corresponding component of input `B`. This operation sequence is found in common formulas—for example, in the point-slope formula of a line, and in the formula to scale and then bias an input.<br /><br /> **Input:**<br /><br /> `M`: `float`, `float2`, `float3`, or `float4`<br /> One of the values to multiply together.<br /><br /> `A`: same as input `M`<br /> One of the values to multiply together.<br /><br /> `B`: same as input `M`<br /> The values to add to the product of the other two inputs.<br /><br /> **Output:**<br /><br /> `Output`: same as input `M`<br /> The result of the multiply-add, per component.|None|
|**Max**|Computes the component-wise maximum of the specified inputs.<br /><br /> For each component of the result, the greater of the corresponding components of the inputs is taken.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> One of the values for which to compute the maximum.<br /><br /> `Y`: same as input `X`<br /> One of the values for which to compute the maximum.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The maximum value, per component.|None|
|**Min**|Computes the component-wise minimum of the specified inputs.<br /><br /> For each component of the result, the lesser of the corresponding components of the inputs is taken.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> One of the values for which to compute the minimum.<br /><br /> `Y`: same as input `X`<br /> One of the values for which to compute the minimum.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The minimum value, per component.|None|
|**Multiply**|Computes the component-wise product of the specified inputs.<br /><br /> For each component of the result, the corresponding components of the inputs `X` and `Y` are multiplied together.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> One of the values to multiply together.<br /><br /> `Y`: same as input `X`<br /> One of the values to multiply together.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The product, per component.|None|
|**Normalize**|Normalizes the specified vector.<br /><br /> A normalized vector retains the direction of the original vector, but not its magnitude. You can use normalized vectors to simplify calculations where the magnitude of a vector isn't important.<br /><br /> **Input:**<br /><br /> `X`: `float2`, `float3`, or `float4`<br /> The vector to normalize.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The normalized vector.|None|
|**One Minus**|Computes the difference between 1 and the specified input per component.<br /><br /> For each component of the result, the corresponding component of the input is subtracted from 1.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values to be subtracted from 1.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The difference between 1 and the specified input, per component.|None|
|**Power**|Computes the component-wise exponentiation (power) of the specified inputs.<br /><br /> For each component of the result, the corresponding component of input `X` is raised to the power of the corresponding component of the input `Y`.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The base values<br /><br /> `Y`: same as input `X`<br /> The exponent values.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The exponentiation, per component.|None|
|**Saturate**|Clamps each component of the specified input to the range [0, 1].<br /><br /> You can use this range to represent percentages and other relative measurements in calculations. For each component of the result, the corresponding component values of the input that are less than 0 are made equal to 0, values that are larger than 1 are made equal to 1, and values that are in the range aren't changed.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values to saturate.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The saturated value, per component.|None|
|**Sin**|Computes the sine of the specified input, in radians, per component.<br /><br /> For each component of the result, the sine of the corresponding component, which is provided in radians, is calculated. The result has components that have values in the range [-1, 1].<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values to compute the sine of, in radians.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The sine, per component.|None|
|**Sqrt**|Computes the square root of the specified input, per component.<br /><br /> For each component of the result, the square root of the corresponding component is calculated.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values for which to compute the square root.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The square root, per component.|None|
|**Subtract**|Computes the component-wise difference of the specified inputs.<br /><br /> For each component of the result, the corresponding component of input `Y` is subtracted from the corresponding component of input `X`. You can use this to compute the vector that extends from the first input to the second.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The values to be subtracted from.<br /><br /> `Y`: same as input `X`<br /> The values to subtract from input `X`.<br /><br /> **Output:**<br /><br /> `Output`: same as input `X`<br /> The difference, per component.|None|
|**Transform 3D Vector**|Transforms the specified 3D vector into a different space.<br /><br /> You can use this to bring points or vectors into a common space so that you can use them to perform meaningful calculations.<br /><br /> **Input:**<br /><br /> `Vector`: `float3`<br /> The vector to transform.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The transformed vector.|**From System**<br /> The native space of the vector.<br /><br /> **To System**<br /> The space to transform the vector into.|

### Utility nodes

In the Shader Designer, utility nodes represent common, useful shader calculations that don't fit neatly into the other categories. Some utility nodes perform simple operations such as appending vectors together or choosing results conditionally, and others perform complex operations such as computing lighting contributions according to popular lighting models.

#### Utility node reference

|Node|Details|Properties|
|----------|-------------|----------------|
|**Append Vector**|Creates a vector by appending the specified inputs together.<br /><br /> **Input:**<br /><br /> `Vector`: `float`, `float2`, or `float3`<br /> The values to append to.<br /><br /> `Value to Append`: `float`<br /> The value to append.<br /><br /> **Output:**<br /><br /> `Output`: `float2`, `float3`, or `float4` depending on the type of input `Vector`<br /> The new vector.|None|
|**Fresnel**|Computes the Fresnel fall-off based on the specified surface normal.<br /><br /> The Fresnel fall-off value expresses how closely the surface normal of the current pixel coincides with the view vector. When the vectors are aligned, the result of the function is 0; the result increases as the vectors become less similar, and reaches its maximum when the vectors are orthogonal. You can use this to make an effect more or less apparent based on the relationship between the orientation of the current pixel and the camera.<br /><br /> **Input:**<br /><br /> `Surface Normal`: `float3`<br /> The surface normal of the current pixel, defined in the current pixel's tangent space. You can use this to perturb the apparent surface normal, as in normal mapping.<br /><br /> **Output:**<br /><br /> `Output`: `float`<br /> The reflectivity of the current pixel.|**Exponent**<br /> The exponent that's used to calculate the Fresnel fall-off.|
|**If**|Conditionally chooses one of three potential results per component. The condition is defined by the relationship between two other specified inputs.<br /><br /> For each component of the result, the corresponding component of one of the three potential results is chosen, based on the relationship between the corresponding components of the first two inputs.<br /><br /> **Input:**<br /><br /> `X`: `float`, `float2`, `float3`, or `float4`<br /> The left-hand side value to compare.<br /><br /> `Y`: same type as input `X`<br /> The right-hand side value to compare.<br /><br /> `X > Y`: same type as input `X`<br /> The values that are chosen when `X` is greater than `Y`.<br /><br /> `X = Y`: same type as input `X`<br /> The values that are chosen when `X` is equal to `Y`.<br /><br /> `X < Y`: same type as input `X`<br /> The values that are chosen when `X` is less than `Y`.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The chosen result, per component.|None|
|**Lambert**|Computes the color of the current pixel according to the Lambert lighting model, by using the specified surface normal.<br /><br /> This color is the sum of ambient color and diffuse lighting contributions under direct lighting. Ambient color approximates the total contribution of indirect lighting, but looks flat and dull without the help of additional lighting. Diffuse lighting helps add shape and depth to an object.<br /><br /> **Input:**<br /><br /> `Surface Normal`: `float3`<br /> The surface normal of the current pixel, defined in the current pixel's tangent space. You can use this to perturb the apparent surface normal, as in normal mapping.<br /><br /> `Diffuse Color`: `float3`<br /> The diffuse color of the current pixel, typically the **Point Color**. If no input is provided, the default value is white.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The diffuse color of the current pixel.|None|
|**Mask Vector**|Masks components of the specified vector.<br /><br /> You can use this to remove specific color channels from a color value, or to prevent specific components from having an effect on subsequent calculations.<br /><br /> **Input:**<br /><br /> `Vector`: `float4`<br /> The vector to mask.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The masked vector.|**Red / X**<br /> **False** to mask out the red (x) component; otherwise, **True**.<br /><br /> **Green / Y**<br /> **False** to mask out the green (y) component; otherwise, **True**.<br /><br /> **Blue / Z**<br /> **False** to mask out the blue (z) component; otherwise, **True**.<br /><br /> **Alpha / W**<br /> **False** to mask out the alpha (w) component; otherwise, **True**.|
|**Reflection Vector**|Computes the reflection vector for the current pixel in tangent space, based on the camera position.<br /><br /> You can use this to calculate reflections, cubemap coordinates, and specular lighting contributions<br /><br /> **Input:**<br /><br /> `Tangent Space Surface Normal`: `float3`<br /> The surface normal of the current pixel, defined in the current pixel's tangent space. You can use this to perturb the apparent surface normal, as in normal mapping.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The reflection vector.|None|
|**Specular**|Computes the specular lighting contribution according to the Phong lighting model, by using the specified surface normal.<br /><br /> Specular lighting gives a shiny, reflective appearance to an object, for example, water, plastic, or metals.<br /><br /> **Input:**<br /><br /> `Surface Normal`: `float3`<br /> The surface normal of the current pixel, defined in the current pixel's tangent space. You can use this to perturb the apparent surface normal, as in normal mapping.<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The color contribution of specular highlights.|None|

### Filter nodes

In the Shader Designer, filter nodes transform an input—for example, a color or texture sample—into a figurative color value. These figurative color values are commonly used in non-photorealistic rendering or as components in other visual effects.

#### Filter node reference

|Node|Details|Properties|
|----------|-------------|----------------|
|**Blur**|Blurs pixels in a texture by using a Gaussian function.<br /><br /> You can use this to reduce color detail or noise in a texture.<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates of the texel to test.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The blurred color value.|**Texture**<br /> The texture register that's associated with the sampler that's used during blurring.|
|**Desaturate**|Reduces the amount of color in the specified color.<br /><br /> As color is removed, the color value approaches its gray-scale equivalent.<br /><br /> **Input:**<br /><br /> `RGB`: `float3`<br /> The color to desaturate.<br /><br /> `Percent`: `float`<br /> The percent of color to remove, expressed as a normalized value in the range [0, 1].<br /><br /> **Output:**<br /><br /> `Output`: `float3`<br /> The desaturated color.|**Luminance**<br /> The weights that are given to the red, green, and blue color components.|
|**Edge Detection**|Detects edges in a texture by using a Canny edge detector. Edge pixels are output as white; nonedge pixels are output as black.<br /><br /> You can use this to identify edges in a texture so that you can use additional effects to treat edge pixels.<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates of the texel to test.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> White if the texel is on an edge; otherwise, black.|**Texture**<br /> The texture register that's associated with the sampler that's used during edge detection.|
|**Sharpen**|Sharpens a texture.<br /><br /> You can use this to highlight fine details in a texture.<br /><br /> **Input:**<br /><br /> `UV`: `float2`<br /> The coordinates of the texel to test.<br /><br /> **Output:**<br /><br /> `Output`: `float4`<br /> The blurred color value.|**Texture**<br /> The texture register that's associated with the sampler that's used during sharpening.|

## Next steps

To learn more, see [Create Shaders with Shader Designer in Visual Studio](how-to-create-a-basic-color-shader.md). 